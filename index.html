<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Visualiseur - Forme d'onde complète & Compression</title>
<style>
  :root{
    --bg:#0f1115; --panel:#16181c; --accent:#4facfe; --muted:#9aa4ad; --text:#e6eef8;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  header{padding:16px;text-align:center;border-bottom:1px solid #11151a}
  h1{margin:0;font-size:18px}
  .wrap{max-width:1100px;margin:18px auto;padding:16px}
  .panel{background:var(--panel);border-radius:12px;padding:12px;margin-bottom:12px;border:1px solid #131518}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .controls .col{min-width:160px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="range"]{width:220px}
  input[type="file"]{color:var(--text)}
  button{background:#1b2128;border:1px solid #232a33;color:var(--text);padding:8px 12px;border-radius:8px;cursor:pointer}
  button.primary{background:var(--accent);color:#06111c;border:0}
  .small{font-size:13px;color:var(--muted)}
  #canvas{width:100%;height:320px;background:#000;border-radius:8px;display:block}
  .legend{display:flex;gap:14px;align-items:center;margin-top:8px;font-size:13px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.orig{background:#b5bdc5}
  .dot.comp{background:var(--accent)}
  .status{margin-left:auto;font-size:13px;color:var(--muted)}
  .footer{font-size:13px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<header>
  <h1>Visualiseur : forme d'onde complète & compression (Offline)</h1>
</header>

<div class="wrap">
  <div class="panel controls">
    <div class="row" style="align-items:center">
      <input type="file" id="file" accept="audio/*">
      <button id="play" class="primary">▶️ Lecture</button>
      <button id="pause">⏸️ Pause</button>
      <button id="stop">⏹️ Stop</button>
      <label class="small" style="margin:0 8px"> <input type="checkbox" id="bypass"> Bypass (écouter original)</label>
      <div class="status" id="status">Aucun fichier chargé</div>
    </div>
  </div>

  <div class="panel">
    <div class="row">
      <div class="col">
        <label>Threshold (dB) <span id="lab-thresh" class="small"></span></label>
        <input type="range" id="thresh" min="-60" max="0" step="1" value="-12">
      </div>
      <div class="col">
        <label>Ratio <span id="lab-ratio" class="small"></span></label>
        <input type="range" id="ratio" min="1" max="20" step="0.5" value="4">
      </div>
      <div class="col">
        <label>Attack (s) <span id="lab-attack" class="small"></span></label>
        <input type="range" id="attack" min="0.001" max="0.5" step="0.001" value="0.01">
      </div>
      <div class="col">
        <label>Release (s) <span id="lab-release" class="small"></span></label>
        <input type="range" id="release" min="0.01" max="1.5" step="0.01" value="0.25">
      </div>
      <div class="col">
        <label>Makeup (dB) <span id="lab-makeup" class="small"></span></label>
        <input type="range" id="makeup" min="-6" max="24" step="0.5" value="0">
      </div>
    </div>
    <div class="footer">Après modification des paramètres la forme d'onde compressée est recalculée (offline) — patience quelques centaines de ms selon la longueur du fichier.</div>
  </div>

  <div class="panel">
    <canvas id="canvas"></canvas>
    <div class="legend">
      <div class="dot orig"></div><div>Original (non compressé) — partie haute</div>
      <div class="dot comp"></div><div>Compressé + Makeup — partie basse</div>
      <div class="status" id="timeLabel"></div>
    </div>
  </div>
</div>

<script>
(async ()=>{

// Utilitaires
const dBtoGain = db => Math.pow(10, db/20);
const gainTodB = g => 20*Math.log10(Math.max(g,1e-12));

const fileEl = document.getElementById('file');
const playBtn = document.getElementById('play');
const pauseBtn = document.getElementById('pause');
const stopBtn = document.getElementById('stop');
const bypassChk = document.getElementById('bypass');
const status = document.getElementById('status');

const threshEl = document.getElementById('thresh');
const ratioEl = document.getElementById('ratio');
const attackEl = document.getElementById('attack');
const releaseEl = document.getElementById('release');
const makeupEl = document.getElementById('makeup');

const labThresh = document.getElementById('lab-thresh');
const labRatio  = document.getElementById('lab-ratio');
const labAttack = document.getElementById('lab-attack');
const labRelease= document.getElementById('lab-release');
const labMakeup = document.getElementById('lab-makeup');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let audioCtx = null;            // pour playback
let offlineCtx = null;          // pour rendu compressé
let originalBuffer = null;      // AudioBuffer chargé
let compressedBuffer = null;    // AudioBuffer rendu offline
let sourceNode = null;          // pour lecture
let isPlaying = false;
let playStartAt = 0;            // audioCtx.currentTime when started
let playOffset = 0;             // seconds offset when paused

// Resize canvas to device pixels
function resizeCanvas(){
  canvas.width = canvas.clientWidth * window.devicePixelRatio;
  canvas.height= canvas.clientHeight* window.devicePixelRatio;
  ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
  if(originalBuffer) renderWaveforms(); 
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// labels init
function refreshLabels(){
  labThresh.textContent = `${threshEl.value} dB`;
  labRatio.textContent  = `${ratioEl.value}:1`;
  labAttack.textContent = `${(+attackEl.value).toFixed(3)} s`;
  labRelease.textContent= `${(+releaseEl.value).toFixed(2)} s`;
  labMakeup.textContent = `${makeupEl.value} dB`;
}
[threshEl,ratioEl,attackEl,releaseEl,makeupEl].forEach(el=>el.addEventListener('input', ()=>{
  refreshLabels();
  // recalcule offline seulement si un buffer est chargé
  if(originalBuffer) renderCompressedOffline();
}));
refreshLabels();

// Load file
fileEl.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  status.textContent = `Chargement ${f.name}...`;
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const ab = await f.arrayBuffer();
  originalBuffer = await audioCtx.decodeAudioData(ab);
  status.textContent = `Fichier chargé — durée ${originalBuffer.duration.toFixed(2)} s`;
  playOffset = 0;
  // draw original and compute compressed offline
  renderWaveforms();
  await renderCompressedOffline(); // build compressedBuffer and redraw
});

// Draw waveforms: original (top) & compressed (bottom)
function renderWaveforms(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,w,h);

  if(!originalBuffer) {
    ctx.fillStyle = '#9aa4ad';
    ctx.font = '14px system-ui';
    ctx.fillText('Charge un fichier audio pour voir la forme d\'onde', 12, 28);
    return;
  }

  // Prepare sample arrays (mono mix)
  function getChannelDataMixed(buf){
    const ch = Math.min(2, buf.numberOfChannels);
    const len = buf.length;
    const out = new Float32Array(len);
    if(ch === 1){
      out.set(buf.getChannelData(0));
      return out;
    }
    const a = buf.getChannelData(0);
    const b = buf.getChannelData(1);
    for(let i=0;i<len;i++){
      out[i] = 0.5*(a[i] + b[i]);
    }
    return out;
  }

  const origData = getChannelDataMixed(originalBuffer);
  const compData = compressedBuffer ? getChannelDataMixed(compressedBuffer) : null;

  // downsample to canvas width using peak per bucket for a DAW-like render
  const px = Math.max(1, Math.floor(w)); // number of samples across
  function buildEnvelope(data){
    const len = data.length;
    const samplesPerBucket = Math.max(1, Math.floor(len/px));
    const env = new Float32Array(px);
    for(let i=0;i<px;i++){
      const start = i*samplesPerBucket;
      const end = Math.min(len, start + samplesPerBucket);
      let min=1, max=-1;
      for(let j=start;j<end;j++){
        const v = data[j];
        if(v < min) min = v;
        if(v > max) max = v;
      }
      // choose peak-to-peak amplitude for visual clarity
      env[i] = (Math.abs(min) > Math.abs(max)) ? min : max;
    }
    return env;
  }

  const envOrig = buildEnvelope(origData);
  const envComp = compData ? buildEnvelope(compData) : null;

  // draw axes/time ticks
  ctx.fillStyle = '#1a1f25';
  ctx.fillRect(0,0,w,h);

  // draw midline separation
  const half = Math.floor(h/2);
  ctx.strokeStyle = '#0f1317';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, half);
  ctx.lineTo(w, half);
  ctx.stroke();

  // time ticks every n seconds
  const duration = originalBuffer.duration;
  const approxTicks = Math.max(2, Math.floor(w/120));
  const step = Math.max(0.5, duration/approxTicks);
  ctx.fillStyle = '#78909a';
  ctx.font = '11px system-ui';
  for(let t=0;t<=duration; t+=step){
    const x = (t/duration) * w;
    ctx.fillText(`${t.toFixed(1)}s`, x+2, h-6);
  }

  // draw original (top half) - center at quarter height (0..1 -> top)
  const paddingY = 6;
  ctx.beginPath();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = '#b5bdc5'; // grey waveform
  for(let i=0;i<envOrig.length;i++){
    const x = (i/envOrig.length)*w;
    const v = envOrig[i];
    const y = (half/2) + (1 - v) * (half/2) - paddingY; // map -1..1 to top quarter
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // label original
  ctx.fillStyle = '#9aa4ad';
  ctx.font = '12px system-ui';
  ctx.fillText('Original', 8, 18);

  // draw compressed (bottom half) - invert mapping
  if(envComp){
    ctx.beginPath();
    ctx.lineWidth = 1.6;
    ctx.strokeStyle = '#4facfe'; // accent
    for(let i=0;i<envComp.length;i++){
      const x = (i/envComp.length)*w;
      const v = envComp[i];
      const y = half + (half/2) + ( - v ) * (half/2) + paddingY; // map -1..1 to bottom quarter
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.fillStyle = '#cfe6ff';
    ctx.fillText('Compressé + Makeup', 8, half + 18);
  } else {
    ctx.fillStyle = '#32444e';
    ctx.fillText('Compressé (pas encore calculé)', 8, half + 18);
  }

  // draw border and time ruler top
  ctx.strokeStyle = '#0b1013';
  ctx.lineWidth = 1;
  ctx.strokeRect(0,0,w,h);
}

// Offline render to produce compressedBuffer
let currentRenderToken = 0; // cancel stale renders by token check
async function renderCompressedOffline(){
  if(!originalBuffer) return;
  const myToken = ++currentRenderToken;
  status.textContent = 'Rendu offline du signal compressé…';
  // create offline context with same sampleRate and channel count
  const sr = originalBuffer.sampleRate;
  const channels = originalBuffer.numberOfChannels;
  const length = originalBuffer.length;
  const offline = new OfflineAudioContext(channels, length, sr);

  // build source buffer
  const src = offline.createBufferSource();
  src.buffer = originalBuffer;
  // compressor node
  const comp = offline.createDynamicsCompressor();
  comp.threshold.value = Number(threshEl.value);
  comp.ratio.value     = Number(ratioEl.value);
  comp.attack.value    = Number(attackEl.value);
  comp.release.value   = Number(releaseEl.value);
  comp.knee.value      = 30; // fixed knee for predictable result (could expose)

  // makeup as gain node (dB)
  const makeupNode = offline.createGain();
  makeupNode.gain.value = dBtoGain(Number(makeupEl.value));

  // chain: src -> comp -> makeup -> destination
  src.connect(comp);
  comp.connect(makeupNode);
  makeupNode.connect(offline.destination);

  src.start(0);
  try{
    const rendered = await offline.startRendering(); // returns AudioBuffer
    // if a newer render started meanwhile, discard this result
    if(myToken !== currentRenderToken) return;
    compressedBuffer = rendered;
    status.textContent = `Rendu compressé prêt — durée ${compressedBuffer.duration.toFixed(2)} s`;
    renderWaveforms();
  }catch(err){
    console.error('Offline rendering failed', err);
    status.textContent = 'Erreur de rendu offline';
  }
}

// Playback: play compressedBuffer (or original if bypass)
function stopPlayback(){
  if(sourceNode){
    try{ sourceNode.stop(); }catch(e){}
    sourceNode.disconnect();
    sourceNode = null;
  }
  isPlaying = false;
}

function startPlayback(){
  if(!originalBuffer) return;
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  stopPlayback();

  const toPlay = bypassChk.checked ? originalBuffer : (compressedBuffer || originalBuffer);
  sourceNode = audioCtx.createBufferSource();
  sourceNode.buffer = toPlay;
  sourceNode.loop = false;
  // output gain
  const out = audioCtx.createGain();
  out.gain.value = 1.0;
  sourceNode.connect(out).connect(audioCtx.destination);
  const offset = playOffset % toPlay.duration;
  sourceNode.start(0, offset);
  playStartAt = audioCtx.currentTime - offset;
  isPlaying = true;

  // when end
  sourceNode.onended = ()=>{
    isPlaying = false;
    playOffset = 0;
  };
}

// UI playback bindings
playBtn.addEventListener('click', ()=>{
  if(isPlaying){
    // ignore if playing
    return;
  } else {
    startPlayback();
  }
});
pauseBtn.addEventListener('click', ()=>{
  if(!isPlaying) return;
  // pause by stopping and storing offset
  const toPlay = bypassChk.checked ? originalBuffer : (compressedBuffer || originalBuffer);
  playOffset = audioCtx ? (audioCtx.currentTime - playStartAt) : 0;
  stopPlayback();
});
stopBtn.addEventListener('click', ()=>{
  stopPlayback();
  playOffset = 0;
});

// initial: nothing loaded
// Prevent blocking UI: renderCompressedOffline only after user adjusts param (already set)
// All parameter changes trigger re-render; we already call renderCompressedOffline after file load and on param input

// ensure user interaction for audio autoplay policy: resume on first play
document.addEventListener('click', ()=>{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }, {once:true});

})();
</script>
</body>
</html>
