<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Visualiseur de Compression Audio</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #000; color: #eee; }
    canvas { border: 1px solid #555; margin: 10px 0; display: block; background: #111; }
    .controls { margin: 10px 0; }
    .controls label { display: inline-block; width: 100px; }
    button { margin: 5px; padding: 5px 10px; }
    #grMeter { width: 50px; height: 150px; background: #111; border: 1px solid #555; display: block; margin-top: 10px; }
    #compGraph { width: 300px; height: 300px; }
  </style>
</head>
<body>
<h2>Visualiseur de Compression Audio</h2>
<input type="file" id="fileInput" accept="audio/*"><br><br>

<div class="controls">
  <label>Threshold:</label>
  <input type="range" id="threshold" min="-60" max="0" value="-12" step="1">
  <span id="threshVal">-12 dB</span><br>

  <label>Ratio:</label>
  <input type="range" id="ratio" min="1" max="20" value="4" step="0.5">
  <span id="ratioVal">4:1</span><br>

  <label>Attack:</label>
  <input type="range" id="attack" min="0" max="1" step="0.01" value="0.01">
  <span id="attackVal">0.01 s</span><br>

  <label>Release:</label>
  <input type="range" id="release" min="0" max="1" step="0.01" value="0.25">
  <span id="releaseVal">0.25 s</span><br>

  <label>Makeup:</label>
  <input type="range" id="makeup" min="0" max="24" value="0" step="1">
  <span id="makeupVal">0 dB</span><br><br>

  <button id="playPause">‚ñ∂Ô∏è Lecture</button>
  <button id="loopBtn">üîÅ Boucle ON</button>
  <button id="abBtn">üîÄ Mode A/B (A: Bypass)</button>
</div>

<h3>Zoom & Navigation</h3>
<label>Zoom:</label>
<input type="range" id="zoom" min="1" max="20" value="1" step="1">
<span id="zoomVal">1x</span><br>

<label>Position:</label>
<input type="range" id="position" min="0" max="100" value="0" step="1">
<span id="posVal">0%</span>

<h3>Original</h3>
<canvas id="canvasOriginal" width="900" height="150"></canvas>
<h3>Compress√©</h3>
<canvas id="canvasCompressed" width="900" height="150"></canvas>

<h3>Gain Reduction (GR Meter)</h3>
<canvas id="grMeter"></canvas>

<h3>Courbe de transfert du compresseur</h3>
<canvas id="compGraph" width="300" height="300"></canvas>

<script>
let audioContext, buffer, source, compressor, makeupGain;
let isPlaying = false, startTime = 0, pauseTime = 0;
let loopEnabled = true;
let modeAB = "A";

const fileInput = document.getElementById("fileInput");
const playPauseBtn = document.getElementById("playPause");
const loopBtn = document.getElementById("loopBtn");
const abBtn = document.getElementById("abBtn");

const threshSlider = document.getElementById("threshold");
const ratioSlider = document.getElementById("ratio");
const attackSlider = document.getElementById("attack");
const releaseSlider = document.getElementById("release");
const makeupSlider = document.getElementById("makeup");

const zoomSlider = document.getElementById("zoom");
const posSlider = document.getElementById("position");

const canvasOriginal = document.getElementById("canvasOriginal");
const canvasCompressed = document.getElementById("canvasCompressed");
const grCanvas = document.getElementById("grMeter");
const compGraph = document.getElementById("compGraph");

const ctxOrig = canvasOriginal.getContext("2d");
const ctxComp = canvasCompressed.getContext("2d");
const ctxGR = grCanvas.getContext("2d");
const ctxGraph = compGraph.getContext("2d");

let samples, compressedSamples;

fileInput.addEventListener("change", handleFile);
playPauseBtn.addEventListener("click", togglePlay);
loopBtn.addEventListener("click", toggleLoop);
abBtn.addEventListener("click", toggleAB);

[threshSlider, ratioSlider, attackSlider, releaseSlider, makeupSlider].forEach(ctrl => {
  ctrl.addEventListener("input", updateCompressorAndRedraw);
});
zoomSlider.addEventListener("input", redraw);
posSlider.addEventListener("input", redraw);

async function handleFile(e){
  const file = e.target.files[0];
  if(!file) return;

  if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

  const arrayBuffer = await file.arrayBuffer();
  buffer = await audioContext.decodeAudioData(arrayBuffer);

  samples = buffer.getChannelData(0);

  await processCompressed();
  redraw();
  drawCompGraph();
}

async function processCompressed(){
  if(!buffer) return;
  const offlineCtx = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
  const source = offlineCtx.createBufferSource();
  source.buffer = buffer;

  const comp = offlineCtx.createDynamicsCompressor();
  comp.threshold.value = parseFloat(threshSlider.value);
  comp.ratio.value = parseFloat(ratioSlider.value);
  comp.attack.value = parseFloat(attackSlider.value);
  comp.release.value = parseFloat(releaseSlider.value);

  const makeup = offlineCtx.createGain();
  makeup.gain.value = Math.pow(10, parseFloat(makeupSlider.value)/20);

  source.connect(comp);
  comp.connect(makeup);
  makeup.connect(offlineCtx.destination);

  source.start();
  const rendered = await offlineCtx.startRendering();
  compressedSamples = rendered.getChannelData(0);
}

function togglePlay(){
  if(!buffer) return;
  if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

  if(isPlaying){
    source.stop();
    pauseTime = audioContext.currentTime - startTime;
    playPauseBtn.textContent = "‚ñ∂Ô∏è Lecture";
    isPlaying = false;
  } else {
    playCurrentMode();
    drawGR();
  }
}

function playCurrentMode(){
  source = audioContext.createBufferSource();
  source.buffer = buffer;
  source.loop = loopEnabled;

  if(modeAB === "A"){
    source.connect(audioContext.destination);
  } else {
    compressor = audioContext.createDynamicsCompressor();
    compressor.threshold.value = parseFloat(threshSlider.value);
    compressor.ratio.value = parseFloat(ratioSlider.value);
    compressor.attack.value = parseFloat(attackSlider.value);
    compressor.release.value = parseFloat(releaseSlider.value);

    makeupGain = audioContext.createGain();
    makeupGain.gain.value = Math.pow(10, parseFloat(makeupSlider.value)/20);

    source.connect(compressor);
    compressor.connect(makeupGain);
    makeupGain.connect(audioContext.destination);
  }

  source.start(0, pauseTime);
  startTime = audioContext.currentTime - pauseTime;
  playPauseBtn.textContent = "‚è∏ Pause";
}

function drawGR(){
  requestAnimationFrame(drawGR);
  ctxGR.clearRect(0,0,grCanvas.width,grCanvas.height);

  if(!compressor || modeAB==="A") return;

  const reduction = Math.max(compressor.reduction ? -compressor.reduction : 0,0);
  const h = (reduction / 60) * grCanvas.height;
  ctxGR.fillStyle = "#ff0000";
  ctxGR.fillRect(0, grCanvas.height - h, grCanvas.width, h);
}

function toggleLoop(){
  loopEnabled = !loopEnabled;
  loopBtn.textContent = loopEnabled ? "üîÅ Boucle ON" : "‚û°Ô∏è Boucle OFF";
  if(source) source.loop = loopEnabled;
}

function toggleAB(){
  modeAB = (modeAB === "A") ? "B" : "A";
  abBtn.textContent = (modeAB === "A") ? "üîÄ Mode A/B (A: Bypass)" : "üîÄ Mode A/B (B: Compress√©)";
  if(isPlaying){
    source.stop();
    playCurrentMode();
  }
}

async function updateCompressorAndRedraw(){
  document.getElementById("threshVal").textContent = threshSlider.value+" dB";
  document.getElementById("ratioVal").textContent = ratioSlider.value+":1";
  document.getElementById("attackVal").textContent = attackSlider.value+" s";
  document.getElementById("releaseVal").textContent = releaseSlider.value+" s";
  document.getElementById("makeupVal").textContent = makeupSlider.value+" dB";

  await processCompressed();
  redraw();
  drawCompGraph();
}

function redraw(){
  const zoom = parseInt(zoomSlider.value);
  const pos = parseInt(posSlider.value)/100;
  document.getElementById("zoomVal").textContent = zoom+"x";
  document.getElementById("posVal").textContent = posSlider.value+"%";

  drawWaveform(ctxOrig, samples, zoom, pos, canvasOriginal, "#44ccff");
  drawWaveform(ctxComp, compressedSamples, zoom, pos, canvasCompressed, "#ff8844");
}

function drawWaveform(ctx, data, zoom, pos, canvas, color){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!data) return;

  const segmentLength = Math.floor(data.length/zoom);
  const start = Math.floor(pos * (data.length - segmentLength));
  const end = Math.min(start+segmentLength, data.length);
  const step = Math.max(1, Math.floor((end-start)/canvas.width));

  const amp = canvas.height/2;
  ctx.beginPath();

  for(let i=0;i<canvas.width;i++){
    const segStart = start + i*step;
    let min=1.0, max=-1.0;
    for(let j=0;j<step;j++){
      const sample = data[segStart+j] || 0;
      if(sample<min) min=sample;
      if(sample>max) max=sample;
    }
    ctx.moveTo(i, amp + min*amp);
    ctx.lineTo(i, amp + max*amp);
  }

  ctx.strokeStyle = color;
  ctx.stroke();
}

// Graphique de transfert du compresseur avec Make-up Gain
function drawCompGraph(){
  ctxGraph.clearRect(0,0,compGraph.width, compGraph.height);

  const threshold = parseFloat(threshSlider.value);
  const ratio = parseFloat(ratioSlider.value);
  const makeUp = parseFloat(makeupSlider.value);

  const width = compGraph.width;
  const height = compGraph.height;

  // axes
  ctxGraph.strokeStyle="#888";
  ctxGraph.beginPath();
  ctxGraph.moveTo(0,height);
  ctxGraph.lineTo(width,0);
  ctxGraph.stroke();

  // seuil
  const threshX = (threshold+60)/60*width;
  ctxGraph.strokeStyle="#ff0";
  ctxGraph.beginPath();
  ctxGraph.moveTo(threshX,0);
  ctxGraph.lineTo(threshX,height);
  ctxGraph.stroke();

  // courbe compression
  ctxGraph.strokeStyle="#0f0";
  ctxGraph.beginPath();
  for(let x=0;x<=width;x++){
    let input = x/width*60-60; // -60 dB √† 0 dB
    let output;
    if(input<threshold){
      output=input + makeUp;
    } else {
      output=threshold + (input-threshold)/ratio + makeUp;
    }
    const y = height - ((output+60)/60)*height;
    if(x===0) ctxGraph.moveTo(x,y); else ctxGraph.lineTo(x,y);
  }
  ctxGraph.stroke();
}
</script>
</body>
</html>
