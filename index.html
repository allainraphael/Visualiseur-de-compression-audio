<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Visualiseur Compression Audio Avanc√©</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 20px;
  background: #000;
  color: #eee;
}
.grid-container {
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 20px;
}
.controls, #compGraphContainer {
  background: #111;
  padding: 10px;
  border: 1px solid #555;
  border-radius: 5px;
  margin-bottom: 10px;
}
.controls label {
  display: inline-block;
  width: 80px;
}
.controls input[type="range"], .controls input[type="number"] {
  width: 150px;
}
button {
  margin: 5px 5px 5px 0;
  padding: 5px 10px;
}
canvas {
  border: 1px solid #555;
  background: #111;
  display: block;
  margin: 10px 0;
}
.zoom-nav {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}
.flex-graph {
  display: flex;
  align-items: flex-start;
}
#grMeter {
  width: 20px !important;
  height: 280px !important;
  margin-left: 10px;
}
</style>
</head>
<body>

<h2>Visualiseur de Compression Audio</h2>
<input type="file" id="fileInput" accept="audio/*"><br><br>

<div class="grid-container">
  <div>
    <div class="controls">
      <label>Threshold:</label>
      <input type="range" id="threshold" min="-60" max="0" value="0" step="1">
      <span id="threshVal">0 dB</span><br>

      <label>Ratio:</label>
      <input type="range" id="ratio" min="1" max="20" value="1" step="0.5">
      <span id="ratioVal">1:1</span><br>

      <label>Attack:</label>
      <input type="range" id="attack" min="0" max="100" value="0">
      <span id="attackVal">0 ms</span><br>

      <label>Release:</label>
      <input type="range" id="release" min="0" max="100" value="0">
      <span id="releaseVal">0 ms</span><br>

      <label>Makeup:</label>
      <input type="range" id="makeup" min="0" max="24" value="0" step="1">
      <span id="makeupVal">0 dB</span><br><br>

      <button id="playPause">‚ñ∂Ô∏è Lecture</button>
      <button id="loopBtn">üîÅ Boucle ON</button>
      <button id="bypassBtn">üö´ Bypass OFF</button>
    </div>

    <div class="flex-graph">
      <div id="compGraphContainer">
        <h3>Courbe de transfert</h3>
        <canvas id="compGraph" width="280" height="280"></canvas>
      </div>
      <canvas id="grMeter" width="20" height="280"></canvas>
    </div>
  </div>

  <div class="waveform-container">
    <div class="zoom-nav">
      <label>Zoom:</label>
      <input type="range" id="zoom" min="1" max="20" value="1" step="1">
      <span id="zoomVal">1x</span>

      <label>Position:</label>
      <input type="range" id="position" min="0" max="100" value="0" step="1">
      <span id="posVal">0%</span>
    </div>

    <h3>Waveform</h3>
    <canvas id="canvasWaveform" width="900" height="600"></canvas>
  </div>
</div>

<script>
let audioContext, buffer, sourceNode, compressorNode, gainNode, analyserNode;
let isPlaying = false, loopEnabled = true, bypassEnabled = false;
let samples;
let compState = { env:0 };

const fileInput = document.getElementById("fileInput");
const playPauseBtn = document.getElementById("playPause");
const loopBtn = document.getElementById("loopBtn");
const bypassBtn = document.getElementById("bypassBtn");

const threshSlider = document.getElementById("threshold");
const ratioSlider = document.getElementById("ratio");
const attackSlider = document.getElementById("attack");
const releaseSlider = document.getElementById("release");
const makeupSlider = document.getElementById("makeup");

const zoomSlider = document.getElementById("zoom");
const posSlider = document.getElementById("position");

const canvasWaveform = document.getElementById("canvasWaveform");
const grCanvas = document.getElementById("grMeter");
const compGraph = document.getElementById("compGraph");

const ctxWaveform = canvasWaveform.getContext("2d");
const ctxGR = grCanvas.getContext("2d");
const ctxGraph = compGraph.getContext("2d");

function sliderToMs(value){
    const min=0.1;
    const max=1000;
    const normalized = value/100;
    return min*Math.pow(max/min, normalized);
}

fileInput.addEventListener("change", handleFile);
playPauseBtn.addEventListener("click", togglePlay);
loopBtn.addEventListener("click", toggleLoop);
bypassBtn.addEventListener("click", toggleBypass);

threshSlider.addEventListener("input", updateCompressor);
ratioSlider.addEventListener("input", updateCompressor);
attackSlider.addEventListener("input",()=>{
    document.getElementById("attackVal").textContent=Math.round(sliderToMs(attackSlider.value))+" ms";
    applyCompressorSettings();
    redraw(); drawCompGraph();
});
releaseSlider.addEventListener("input",()=>{
    document.getElementById("releaseVal").textContent=Math.round(sliderToMs(releaseSlider.value))+" ms";
    applyCompressorSettings();
    redraw(); drawCompGraph();
});
makeupSlider.addEventListener("input",()=>{
    document.getElementById("makeupVal").textContent=makeupSlider.value+" dB";
    if(gainNode && !bypassEnabled) gainNode.gain.value = Math.pow(10, parseFloat(makeupSlider.value)/20);
    redraw(); drawCompGraph();
});

zoomSlider.addEventListener("input", redraw);
posSlider.addEventListener("input", redraw);

async function handleFile(e){
  const file = e.target.files[0];
  if(!file) return;
  if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

  threshSlider.value=0; ratioSlider.value=1; attackSlider.value=0; releaseSlider.value=0; makeupSlider.value=0;
  updateCompressorValuesDisplay();
  compState.env=0;

  const arrayBuffer = await file.arrayBuffer();
  buffer = await audioContext.decodeAudioData(arrayBuffer);
  samples = buffer.getChannelData(0).slice();

  redraw();
  updateCompressor();
}

function togglePlay(){
  if(!buffer) return;

  if(isPlaying){
    stopSource();
    playPauseBtn.textContent="‚ñ∂Ô∏è Lecture";
    isPlaying=false;
  } else {
    playSource();
    playPauseBtn.textContent="‚è∏ Pause";
    isPlaying=true;
  }
}

function stopSource() {
  if (sourceNode) { try { sourceNode.stop(); } catch(e){} sourceNode.disconnect(); sourceNode=null; }
  if (compressorNode) { compressorNode.disconnect(); compressorNode=null; }
  if (gainNode) { gainNode.disconnect(); gainNode=null; }
  if (analyserNode) { analyserNode.disconnect(); analyserNode=null; }
}

function playSource() {
  stopSource();

  sourceNode = audioContext.createBufferSource();
  sourceNode.buffer = buffer;
  sourceNode.loop = loopEnabled;

  analyserNode = audioContext.createAnalyser();
  analyserNode.fftSize = 2048;

  if(bypassEnabled){
    sourceNode.connect(analyserNode);
  } else {
    compressorNode = audioContext.createDynamicsCompressor();
    applyCompressorSettings();

    gainNode = audioContext.createGain();
    gainNode.gain.value = Math.pow(10, parseFloat(makeupSlider.value)/20);

    sourceNode.connect(compressorNode);
    compressorNode.connect(gainNode);
    gainNode.connect(analyserNode);
  }

  analyserNode.connect(audioContext.destination);

  sourceNode.start();

  sourceNode.onended = () => {
    if(!loopEnabled){
      stopSource();
      isPlaying=false;
      playPauseBtn.textContent="‚ñ∂Ô∏è Lecture";
    }
  };

  drawGRRealtime();
  redraw();
  drawCompGraph();
}

function toggleBypass(){
  bypassEnabled = !bypassEnabled;
  bypassBtn.textContent = bypassEnabled ? "üö´ Bypass ON" : "üö´ Bypass OFF";

  if(isPlaying){
    playSource();
  }
  // üîπ La visualisation continue √† suivre les sliders m√™me en bypass
  redraw(); drawCompGraph();
}

function applyCompressorSettings(){
  if(!compressorNode) return;
  compressorNode.threshold.value = parseFloat(threshSlider.value);
  compressorNode.ratio.value = parseFloat(ratioSlider.value);
  compressorNode.attack.value = sliderToMs(parseFloat(attackSlider.value))/1000;
  compressorNode.release.value = sliderToMs(parseFloat(releaseSlider.value))/1000;
}

function updateCompressor(){
  updateCompressorValuesDisplay();
  applyCompressorSettings();
  compState.env=0;

  // üîπ Simulation visuelle toujours recalcul√©e
  redraw(); drawCompGraph();
}

function updateCompressorValuesDisplay(){
  document.getElementById("threshVal").textContent=threshSlider.value+" dB";
  document.getElementById("ratioVal").textContent=ratioSlider.value+":1";
  document.getElementById("attackVal").textContent=Math.round(sliderToMs(attackSlider.value))+" ms";
  document.getElementById("releaseVal").textContent=Math.round(sliderToMs(releaseSlider.value))+" ms";
  document.getElementById("makeupVal").textContent=makeupSlider.value+" dB";
}

function redraw(){
  const zoom = parseInt(zoomSlider.value);
  const pos = parseInt(posSlider.value)/100;
  document.getElementById("zoomVal").textContent=zoom+"x";
  document.getElementById("posVal").textContent=Math.round(pos*100)+"%";
  drawCombinedWaveform(ctxWaveform, samples, zoom, pos, canvasWaveform);
}

function drawCombinedWaveform(ctx, data, zoom, pos, canvas){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!data || data.length===0) return;
  const totalLength = data.length;
  const segmentLength = Math.floor(totalLength/zoom);
  let start = Math.floor(pos*(totalLength - segmentLength));
  start = Math.max(0, Math.min(start, totalLength-1));
  let end = Math.min(start+segmentLength, totalLength);
  const step = Math.max(1, Math.floor((end-start)/canvas.width));
  let peak = 0;
  for(let i=start;i<end;i++){
    const s=Math.abs(data[i]);
    if(s>peak) peak=s;
  }
  if(peak===0) peak=1;
  const amp = canvas.height/2;

  ctx.beginPath();
  for(let i=0;i<canvas.width;i++){
    const segStart = start + i*step;
    let min=1,max=-1;
    for(let j=0;j<step;j++){
      let idx = segStart+j;
      if(idx>=totalLength) break;
      let s = data[idx]/peak;
      if(s<min) min=s;
      if(s>max) max=s;
    }
    ctx.moveTo(i, amp+min*amp);
    ctx.lineTo(i, amp+max*amp);
  }
  ctx.strokeStyle="#44ccff";
  ctx.stroke();

  ctx.beginPath();
  let state={env:0};
  for(let i=0;i<canvas.width;i++){
    const segStart = start + i*step;
    let min=1,max=-1;
    for(let j=0;j<step;j++){
      let idx = segStart+j;
      if(idx>=totalLength) break;
      let s = compressSampleRealtime(data[idx],state)*Math.pow(10, parseFloat(makeupSlider.value)/20)/peak;
      if(s<min) min=s;
      if(s>max) max=s;
    }
    ctx.moveTo(i, amp+min*amp);
    ctx.lineTo(i, amp+max*amp);
  }
  ctx.strokeStyle="#ff8844";
  ctx.stroke();
}

function compressSampleRealtime(sample,state){
    const threshold = parseFloat(threshSlider.value);
    const ratio = parseFloat(ratioSlider.value);
    const attack = sliderToMs(parseFloat(attackSlider.value))/1000;
    const release = sliderToMs(parseFloat(releaseSlider.value))/1000;

    const eps = 1e-8;
    let dbSample = 20*Math.log10(Math.abs(sample)+eps);
    let gainDb = 0;
    if(dbSample > threshold){
        gainDb = threshold + (dbSample-threshold)/ratio - dbSample;
    }
    const coeff = (gainDb < state.env) 
                  ? Math.exp(-1/(audioContext.sampleRate*attack || 1e-3))
                  : Math.exp(-1/(audioContext.sampleRate*release || 1e-3));
    state.env = state.env*coeff + gainDb*(1-coeff);
    return sample*Math.pow(10,state.env/20);
}

function drawCompGraph(){
  ctxGraph.clearRect(0,0,compGraph.width,compGraph.height);
  const threshold=parseFloat(threshSlider.value);
  const ratio=parseFloat(ratioSlider.value);
  const width=compGraph.width;
  const height=compGraph.height;
  const threshX=(threshold+60)/60*width;

  ctxGraph.strokeStyle="#ff0";
  ctxGraph.beginPath();
  ctxGraph.moveTo(threshX,0);
  ctxGraph.lineTo(threshX,height);
  ctxGraph.stroke();

  ctxGraph.strokeStyle="#0f0";
  ctxGraph.beginPath();
  for(let x=0;x<=width;x++){
    let input=x/width*60-60;
    let output;
    if(input<threshold) output=input;
    else output=threshold+(input-threshold)/ratio;
    const y=height-((output+60)/60)*height;
    if(x===0) ctxGraph.moveTo(x,y); else ctxGraph.lineTo(x,y);
  }
  ctxGraph.stroke();
}

function drawGRRealtime(){
  requestAnimationFrame(drawGRRealtime);
  ctxGR.clearRect(0,0,grCanvas.width,grCanvas.height);
  if(!compressorNode) return;

  const reduction = compressorNode.reduction; // dB n√©gatif
  const minReduction = -30;
  const norm = Math.max(minReduction, reduction);
  const height = grCanvas.height;
  const y = ((0 - norm)/-minReduction) * height;

  ctxGR.fillStyle = "#222";
  ctxGR.fillRect(0,0,grCanvas.width,height);

  ctxGR.fillStyle = "red";
  ctxGR.fillRect(0,0,grCanvas.width,y);

  ctxGR.fillStyle = "#ffff66";
  ctxGR.font = "12px bold Arial";
  ctxGR.textAlign = "left";
  for(let dB=0; dB>=minReduction; dB-=6){
    let lineY = ((0 - dB)/-minReduction) * height;
    ctxGR.strokeStyle = "#444";
    ctxGraph.beginPath();
    ctxGR.moveTo(0,lineY);
    ctxGR.lineTo(grCanvas.width,lineY);
    ctxGR.stroke();
    ctxGR.fillText(dB+" dB", grCanvas.width+4, lineY+4);
  }
}

function toggleLoop(){
  loopEnabled = !loopEnabled;
  loopBtn.textContent = loopEnabled ? "üîÅ Boucle ON":"üîÅ Boucle OFF";
  if(sourceNode) sourceNode.loop = loopEnabled;
}
</script>

</body>
</html>
