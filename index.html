<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Visualiseur de Compression Audio</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #000; color: #eee; }
    canvas { border: 1px solid #555; margin: 10px 0; display: block; background: #111; }
    .controls { margin: 10px 0; }
    .controls label { display: inline-block; width: 100px; }
    button { margin: 5px; padding: 5px 10px; }
    #grMeter { width: 50px; height: 150px; background: #111; border: 1px solid #555; display: block; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Visualiseur de Compression Audio</h2>
  <input type="file" id="fileInput" accept="audio/*"><br><br>

  <div class="controls">
    <label>Threshold:</label>
    <input type="range" id="threshold" min="-60" max="0" value="-12" step="1">
    <span id="threshVal">-12 dB</span><br>

    <label>Ratio:</label>
    <input type="range" id="ratio" min="1" max="20" value="4" step="0.5">
    <span id="ratioVal">4:1</span><br>

    <label>Attack:</label>
    <input type="range" id="attack" min="0" max="1" step="0.01" value="0.01">
    <span id="attackVal">0.01 s</span><br>

    <label>Release:</label>
    <input type="range" id="release" min="0" max="1" step="0.01" value="0.25">
    <span id="releaseVal">0.25 s</span><br>

    <label>Makeup:</label>
    <input type="range" id="makeup" min="0" max="24" value="0" step="1">
    <span id="makeupVal">0 dB</span><br><br>

    <button id="playPause">‚ñ∂Ô∏è Lecture</button>
    <button id="loopBtn">üîÅ Boucle ON</button>
    <button id="abBtn">üîÄ Mode A/B (A: Bypass)</button>
  </div>

  <h3>Zoom & Navigation</h3>
  <label>Zoom:</label>
  <input type="range" id="zoom" min="1" max="20" value="1" step="1">
  <span id="zoomVal">1x</span><br>

  <label>Position:</label>
  <input type="range" id="position" min="0" max="100" value="0" step="1">
  <span id="posVal">0%</span>

  <h3>Original</h3>
  <canvas id="canvasOriginal" width="900" height="150"></canvas>
  <h3>Compress√©</h3>
  <canvas id="canvasCompressed" width="900" height="150"></canvas>

  <h3>Gain Reduction (GR Meter)</h3>
  <canvas id="grMeter"></canvas>

<script>
let audioContext, buffer, source, compressor, gainNode;
let isPlaying = false, startTime = 0, pauseTime = 0;
let loopEnabled = true;
let modeAB = "A"; // A = original, B = compress√©

const fileInput = document.getElementById("fileInput");
const playPauseBtn = document.getElementById("playPause");
const loopBtn = document.getElementById("loopBtn");
const abBtn = document.getElementById("abBtn");

const threshSlider = document.getElementById("threshold");
const ratioSlider = document.getElementById("ratio");
const attackSlider = document.getElementById("attack");
const releaseSlider = document.getElementById("release");
const makeupSlider = document.getElementById("makeup");

const zoomSlider = document.getElementById("zoom");
const posSlider = document.getElementById("position");

const canvasOriginal = document.getElementById("canvasOriginal");
const canvasCompressed = document.getElementById("canvasCompressed");
const grCanvas = document.getElementById("grMeter");
const ctxOrig = canvasOriginal.getContext("2d");
const ctxComp = canvasCompressed.getContext("2d");
const ctxGR = grCanvas.getContext("2d");

let samples, compressedSamples;
let analyser, dataArray;

fileInput.addEventListener("change", handleFile);
playPauseBtn.addEventListener("click", togglePlay);
loopBtn.addEventListener("click", toggleLoop);
abBtn.addEventListener("click", toggleAB);

[threshSlider, ratioSlider, attackSlider, releaseSlider, makeupSlider].forEach(ctrl => {
  ctrl.addEventListener("input", updateCompressorAndRedraw);
});
zoomSlider.addEventListener("input", redraw);
posSlider.addEventListener("input", redraw);

async function handleFile(e){
  const file = e.target.files[0];
  if(!file) return;

  if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

  const arrayBuffer = await file.arrayBuffer();
  buffer = await audioContext.decodeAudioData(arrayBuffer);

  samples = buffer.getChannelData(0); // mono pour affichage

  await processCompressed();
  setupAnalyser();
  redraw();
}

async function processCompressed(){
  if(!buffer) return;
  const offlineCtx = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
  const source = offlineCtx.createBufferSource();
  source.buffer = buffer;

  const comp = offlineCtx.createDynamicsCompressor();
  comp.threshold.value = parseFloat(threshSlider.value);
  comp.ratio.value = parseFloat(ratioSlider.value);
  comp.attack.value = parseFloat(attackSlider.value);
  comp.release.value = parseFloat(releaseSlider.value);

  const makeup = offlineCtx.createGain();
  makeup.gain.value = Math.pow(10, parseFloat(makeupSlider.value)/20);

  source.connect(comp);
  comp.connect(makeup);
  makeup.connect(offlineCtx.destination);

  source.start();
  const rendered = await offlineCtx.startRendering();
  compressedSamples = rendered.getChannelData(0);
}

function setupAnalyser(){
  if(!audioContext) return;
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 2048;
  dataArray = new Float32Array(analyser.fftSize);
}

function togglePlay(){
  if(!buffer) return;
  if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();

  if(isPlaying){
    source.stop();
    pauseTime = audioContext.currentTime - startTime;
    playPauseBtn.textContent = "‚ñ∂Ô∏è Lecture";
    isPlaying = false;
  } else {
    playCurrentMode();
    drawGR();
  }
}

function playCurrentMode(){
  source = audioContext.createBufferSource();

  if(modeAB === "A"){ // Bypass
    source.buffer = buffer;
    source.loop = loopEnabled;
    source.connect(audioContext.destination);
    analyser.disconnect();
  } else { // Compress√©
    source.buffer = buffer;
    source.loop = loopEnabled;

    compressor = audioContext.createDynamicsCompressor();
    compressor.threshold.value = parseFloat(threshSlider.value);
    compressor.ratio.value = parseFloat(ratioSlider.value);
    compressor.attack.value = parseFloat(attackSlider.value);
    compressor.release.value = parseFloat(releaseSlider.value);

    gainNode = audioContext.createGain();
    gainNode.gain.value = Math.pow(10, parseFloat(makeupSlider.value)/20);

    source.connect(compressor);
    compressor.connect(gainNode);
    gainNode.connect(audioContext.destination);

    // Connecter analyser pour GR meter
    gainNode.connect(analyser);
  }

  source.start(0, pauseTime);
  startTime = audioContext.currentTime - pauseTime;
  playPauseBtn.textContent = "‚è∏ Pause";
  isPlaying = true;
}

function toggleLoop(){
  loopEnabled = !loopEnabled;
  loopBtn.textContent = loopEnabled ? "üîÅ Boucle ON" : "‚û°Ô∏è Boucle OFF";
  if(source) source.loop = loopEnabled;
}

function toggleAB(){
  modeAB = (modeAB === "A") ? "B" : "A";
  abBtn.textContent = (modeAB === "A") ? "üîÄ Mode A/B (A: Bypass)" : "üîÄ Mode A/B (B: Compress√©)";

  if(isPlaying){
    source.stop();
    playCurrentMode();
  }
}

async function updateCompressorAndRedraw(){
  document.getElementById("threshVal").textContent = threshSlider.value+" dB";
  document.getElementById("ratioVal").textContent = ratioSlider.value+":1";
  document.getElementById("attackVal").textContent = attackSlider.value+" s";
  document.getElementById("releaseVal").textContent = releaseSlider.value+" s";
  document.getElementById("makeupVal").textContent = makeupSlider.value+" dB";

  await processCompressed();
  redraw();
}

function redraw(){
  const zoom = parseInt(zoomSlider.value);
  const pos = parseInt(posSlider.value)/100;
  document.getElementById("zoomVal").textContent = zoom+"x";
  document.getElementById("posVal").textContent = posSlider.value+"%";

  drawWaveform(ctxOrig, samples, zoom, pos, canvasOriginal, "#44ccff");
  drawWaveform(ctxComp, compressedSamples, zoom, pos, canvasCompressed, "#ff8844");
}

function drawWaveform(ctx, data, zoom, pos, canvas, color){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!data) return;

  const segmentLength = Math.floor(data.length/zoom);
  const start = Math.floor(pos * (data.length - segmentLength));
  const end = Math.min(start+segmentLength, data.length);
  const step = Math.max(1, Math.floor((end-start)/canvas.width));

  const amp = canvas.height/2;
  ctx.beginPath();

  for(let i=0;i<canvas.width;i++){
    const segStart = start + i*step;
    let min=1.0, max=-1.0;
    for(let j=0;j<step;j++){
      const sample = data[segStart+j] || 0;
      if(sample<min) min=sample;
      if(sample>max) max=sample;
    }
    ctx.moveTo(i, amp + min*amp);
    ctx.lineTo(i, amp + max*amp);
  }

  ctx.strokeStyle = color;
  ctx.stroke();
}

// Draw Gain Reduction meter
function drawGR(){
  if(!compressor || !isPlaying) return;

  requestAnimationFrame(drawGR);

  analyser.getFloatTimeDomainData(dataArray);
  let maxReduction = 0;

  // Approximation de la r√©duction en dB
  // Plus le signal sort du compresseur par rapport √† l'entr√©e
  for(let i=0; i<dataArray.length; i++){
    const input = samples[i] || 0;
    const output = compressedSamples[i] || 0;
    const reduction = 20*Math.log10(Math.max(Math.abs(output)/Math.max(Math.abs(input),0.00001),0.0001));
    if(reduction < maxReduction) maxReduction = reduction;
  }

  const gr = Math.abs(maxReduction); // en dB positif
  const height = grCanvas.height;
  ctxGR.clearRect(0,0,grCanvas.width,grCanvas.height);
  ctxGR.fillStyle = "#ff0000";
  const h = Math.min(height, (gr/60)*height);
  ctxGR.fillRect(0, height-h, grCanvas.width, h);
}
</script>
</body>
</html>
